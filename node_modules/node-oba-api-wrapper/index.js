const OBA = require("oba-api");
const chalk = require("chalk");
const cliProgress = require("cli-progress");
const { filterAsync } = require("node-filter-async");

function sanitizeOptionObject (options, page, rctx) {
	const customOptions = ["count", "filter", "log", "map"];
	const safeOptions = Object.keys(options)
		.filter(key => !customOptions.includes(key))
		.reduce((obj, key) => {
			return {
				...obj,
				[key]: options[key]
			};
		}, {});
	if (rctx) safeOptions.rctx = rctx;
	if (page) safeOptions.page = page;
	return safeOptions;
}

function log (string, options) {
	if (options.log) console.log(string);
}

module.exports = class OBAWrapper {
	constructor (options) {
		this.client = new OBA(options);
		this.rctx = null;
		this.maxResultCount = null;
		this.currentResultCount = null;
		this.targetCount = null;
	}

	async get (endpoint, options) {
		const progressBar = new cliProgress.Bar({
			format: `Requesting ${chalk.magentaBright("{value}")}/${chalk.magentaBright(options.count)} items [{bar}] ${chalk.magentaBright("{percentage}")}% `,
			barsize: 20,
			barIncompleteChar: "≡",
			barCompleteChar: "■",
			fps: 5
		});
		const results = [];
		let page = 1;
		
		//If no count given, revert to default API behaviour
		if (!options.count) options.count = 20; //Maybe use Infinity instead?
		this.targetCount = options.count;

		//Set progress bar
		progressBar.start(options.count, 0);

		while (results.length < options.count) {
			//Send out initial request
			const response = JSON.parse(await this.client.get(endpoint, sanitizeOptionObject(options, page++, this.rctx)));
			
			//Get context to speed up following requests.
			if (!this.rctx) this.rctx = response.aquabrowser.meta.rctx;

			//Save current request results locally
			let __results = response.aquabrowser.results.result;

			//Save count before filtering to prevent over-requesting later
			this.currentResultCount += __results.length;

			//Optionally filter and/or map results
			if (options.filter) {
				__results = await filterAsync(__results, async result => {
					return await options.filter(result);
				});
			}
			if (options.map) {
				__results = await Promise.all(__results.map(async result => {
					return await options.map(result);
				}));
			}

			//Make sure the API can actually provide the number of items the user requested
			if (this.maxResultCount === null) this.maxResultCount = Number(response.aquabrowser.meta.count);
			if (options.count > this.maxResultCount) {
				options.count = this.maxResultCount;
			}

			//Push individual values to skip flattening later
			results.push(...__results);

			//idk
			if ((this.currentResultCount >= this.maxResultCount) && (results.length < this.targetCount)) {
				log(` | ${chalk.bold("Warning:")} There aren't ${this.targetCount} items that comply to your filter.`, options);
				break;
			}

			//Update progress bar
			progressBar.update(results.length);
		}

		//Stop progress bar
		progressBar.stop();

		//Cull any extra results
		if (results.length > options.count) results.length = options.count;

		//Do some nice logging
		log(chalk.greenBright("Succesfully returned")
			+ " "
			+ chalk.magentaBright(results.length)
			+ "/"
			+ chalk.magentaBright(this.maxResultCount)
			+ " "
			+ chalk.greenBright("items."), options);

		//Reset instance to allow other requests
		this.rctx = null;
		this.maxResultCount = null;
		this.currentResultCount = null;
		this.targetCount = null;
		
		return results;
	}
}